package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
)

/*This var is a pointer towards template.Template that is a
pointer to help process the html.*/
var tpl *template.Template

/*This init function, once it's initialised, makes it so that each html file
in the templates folder is parsed i.e. they all get looked through once and
then stored in the memory ready to go when needed*/
func init() {
	tpl = template.Must(template.ParseGlob("templates/*html"))
}

var (
	ArtistID              []int
	ArtistImage           []string
	ArtistName            []string
	ArtistMembers         [][]string
	ArtistCreationDate    []int
	ArtistFirstAlbum      []string
	ArtistLocations       [][]string
	ArtistConcertDates    [][]string
	ArtistsDatesLocations map[string][]string
)

type Artists []struct {
	ID           int      `json:"id"`
	Image        string   `json:"image"`
	Name         string   `json:"name"`
	Members      []string `json:"members"`
	CreationDate int      `json:"creationDate"`
	FirstAlbum   string   `json:"firstAlbum"`
	Locations    string   `json:"locations"`
	ConcertDates string   `json:"concertDates"`
	Relations    string   `json:"relations"`
}

type Dates struct {
	Dates []dates `json:"index"`
}

type dates struct {
	ID    int      `json:"id"`
	Dates []string `json:"dates"`
}
type Locations struct {
	Locations []locations `json:"index"`
}

type locations struct {
	ID        int      `json:"id"`
	Locations []string `json:"locations"`
	Dates     string   `json:"dates"`
}

type Relation struct {
	Relation []relations `json:"index"`
}

type relations struct {
	ID             int                 `json:"id"`
	DatesLocations map[string][]string `json:"datesLocations"`
}

func main() {

	responseArtists, err := http.Get("https://groupietrackers.herokuapp.com/api/artists")
	if err != nil {
		panic("Couldn't get Artists info from API")
	}
	defer responseArtists.Body.Close()

	responseArtistsData, err := ioutil.ReadAll(responseArtists.Body)
	if err != nil {
		panic("Couldn't read data for Artists!")
	}

	var responseObjectArtists Artists
	json.Unmarshal(responseArtistsData, &responseObjectArtists)

	// for i := 0; i < len(responseObjectArtists); i++ {
	// 	ArtistImage = append(ArtistImage, responseObjectArtists[i].Image)
	// }

	// fmt.Println(ArtistLocations[0])

	//requests()

	responseRelations, err := http.Get("https://groupietrackers.herokuapp.com/api/relation")
	if err != nil {
		panic("Couldn't get the relations data!")
	}

	responseData, err := ioutil.ReadAll(responseRelations.Body)
	if err != nil {
		panic("Couldn't read data for the Artists")
	}

	var responseObjectRelation Relation

	json.Unmarshal(responseData, &responseObjectRelation)

	ArtistsDatesLocations := responseObjectRelation.Relation

	for i := 0; i < len(ArtistsDatesLocations); i++ {

		fmt.Println(ArtistsDatesLocations[i])
	}

	// for i:= 0; i<len(responseObjectRelation.Relation); i++{
	// 	ArtistsDatesLocations = append(ArtistsDatesLocations, responseObjectRelation.Relation[i])
	// }

	// responseLocations, err := http.Get("https://groupietrackers.herokuapp.com/api/locations")
	// if err != nil {
	// 	panic("Couldn't get Location info from API")
	// }
	// defer responseLocations.Body.Close()

	// responseLocationsData, err := ioutil.ReadAll(responseLocations.Body)
	// if err != nil {
	// 	panic("Couldn't read data for Locations!")
	// }

	// var responseObjectLocations Locations
	// json.Unmarshal(responseLocationsData, &responseObjectLocations)

	// //fmt.Println(responseObjectLocations.Locations[0].Locations)

	// for i := 0; i < len(responseObjectLocations.Locations); i++ {
	// 	ArtistLocations = append(ArtistLocations, responseObjectLocations.Locations[i].Locations)
	// }

	// fmt.Println(ArtistLocations[0])

	// for i := 0; i < len(responseObjectLocations.Locations); i++ {
	// 	ArtistID = append(ArtistID, responseObjectLocations.Locations[i].ID)
	// }

	// // for i := 0; i < len(ArtistLocations); i++ {
	// // 	fmt.Println(ArtistID[i], ArtistLocations[i])
	// // }

	// responseDates, err := http.Get("https://groupietrackers.herokuapp.com/api/dates")
	// if err != nil {
	// 	panic("Couldn't get Dates info from the API!")
	// }
	// defer responseDates.Body.Close()

	// responseDatesData, err := ioutil.ReadAll(responseDates.Body)
	// if err != nil {
	// 	panic("Couldn't read data for Dates")
	// }

	// var responseObjectDates Dates
	// json.Unmarshal(responseDatesData, &responseObjectDates)

	// for i := 0; i < len(responseObjectDates.Dates); i++ {
	// 	ArtistConcertDates = append(ArtistConcertDates, responseObjectDates.Dates[i].Dates)
	// }

	// // for i := 0; i < len(ArtistConcertDates); i++ {
	// // 	fmt.Println(ArtistConcertDates[i])
	// // }

	// fmt.Println(ArtistConcertDates[1])

	requests()

}

func requests() {

	http.HandleFunc("/", index)
	http.HandleFunc("/info", artistInfo)
	http.ListenAndServe(":8080", nil)
	log.Println("Server started on: http://localhost:8080")
}
func index(w http.ResponseWriter, r *http.Request) {

	//--------------Unmarshall Artists-------------------
	responseArtists, err := http.Get("https://groupietrackers.herokuapp.com/api/artists")
	if err != nil {
		panic("Couldn't get Artists info from API")
	}
	defer responseArtists.Body.Close()

	responseArtistsData, err := ioutil.ReadAll(responseArtists.Body)
	if err != nil {
		panic("Couldn't read data for Artists!")
	}

	var responseObjectArtists []Artists
	json.Unmarshal(responseArtistsData, &responseObjectArtists)

	for i := 0; i < len(responseObjectArtists); i++ {
		ArtistID = append(ArtistID, ArtistID[i])
	}

	//--------------Unmarshall Locations-------------------

	responseLocations, err := http.Get("https://groupietrackers.herokuapp.com/api/locations")
	if err != nil {
		panic("Couldn't get Location info from API")
	}
	defer responseLocations.Body.Close()

	responseLocationsData, err := ioutil.ReadAll(responseLocations.Body)
	if err != nil {
		panic("Couldn't read data for Locations!")
	}

	var responseObjectLocations []Locations
	json.Unmarshal(responseLocationsData, &responseObjectLocations)

	for i := 0; i < len(responseObjectLocations); i++ {
		fmt.Println(responseObjectLocations[i])
	}

	//--------------Unmarshall Dates-------------------
	responseDates, err := http.Get("https://groupietrackers.herokuapp.com/api/dates")
	if err != nil {
		panic("Couldn't get Dates info from the API!")
	}
	defer responseDates.Body.Close()

	responseDatesData, err := ioutil.ReadAll(responseDates.Body)
	if err != nil {
		panic("Couldn't read data for Dates")
	}

	var responseObjectDates Dates
	json.Unmarshal(responseDatesData, &responseObjectDates)

	//-------------Create a struct to hold unmarshalled data-----------

	// var TotalInfo []struct {
	// 	responseObjectArtists   Artists
	// 	responseObjectLocations Locations.Index
	// 	responseObjectDates     Dates
	// }

	if r.URL.Path != "/" {
		http.Error(w, "404 address not found: wrong address entered!", http.StatusNotFound)
	} else {

		tpl.ExecuteTemplate(w, "index.html", responseObjectArtists)
	}
}

func artistInfo(w http.ResponseWriter, r *http.Request) {

	response, err := http.Get("https://groupietrackers.herokuapp.com/api/relation")
	if err != nil {
		panic("Couldn't get the relations data!")
	}

	responseData, err := ioutil.ReadAll(response.Body)
	if err != nil {
		panic("Couldn't read data for the Artists")
	}

	var responseObject Relation

	json.Unmarshal(responseData, &responseObject)

	if r.URL.Path != "/info" {
		http.Error(w, "404 address not found: wrong address entered!", http.StatusNotFound)
	} else {

		//tpl.ExecuteTemplate(w, "info.html", responseObject.Index)
	}

}
